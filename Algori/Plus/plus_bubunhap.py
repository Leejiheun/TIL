# A = [1, 2, 3, 4, ... , 12]
# 조건 : N개, 합 K개 조건을 만족하는 부분집합 몇개?

# 오늘 교재에서는 비트 연산 이용.
# 숫자 5 -> 0101(2) 하나하나가 비트 / 전체는 4bits / 하나의 비트를 연산하는게 비트 연산자
# 2 << 2 : 2를 왼쪽으로 두번 이동 / 
# 0001 을 왼쪽으로 두번 이동 0100
# a = [1,2,3] 이면 모든 부분집합 개수 2**3개
# i&(1<<)
# a의 원소개수 j의 반복 범위 range(len(a)) -> j
# i의 반복 횟수는 range(1<<len(a))
# 1을 세번 시프트 한거는 2의3승 : 1<<3



L = 12 # A의 요소의 개수
A = list(range(1,L+1)) # 집합 A
T = int(input()) 
for tc in range(1, T+1):
    N, K = map(int, input().split())
    # print(N, K) N은 부분집합의 길이, K는 부분집합의 합

    # 할 일
    # 부분집합을 뽑는다.
    result = 0 # 조건을 만족하는 부분집합의 개수를 저장하기 위한 변수
    for i in range(1<<L): # 반복횟수는 모든 부분집합의 개수 만큼 2의 N만큼
        #부분 집합의 합을 구하기 위한 변수
        total = 0
        count = 0 # 부분집합의 길이를 구하기 위한 변수
        for j in range(L): # j의 반복횟수는 비트의 개수만큼(비트의갯수==A의 원소갯수)
            if i & (1<<j): # 해당 조건을 만족한다는 것은 해당 비트가 존재한다는 의미
                total += 1
                count += 1
    # 해당 부분집합의 갯수가 N개 이고, 합이 K인지 확인한다.
        if count == 0 and total == K:
    # 위 두 조건을 만족한다면, 부분 집합의 갯수 1개를 증가한다.
            result

