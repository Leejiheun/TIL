# 알고리즘 효율
- 적은 메모리 공간, 적은 시간
- 시간복잡도 : 반복문을 얼마나 많이
    1. O(Big-Oh) 표기법
    2. Big-Omega 표기
    3. Big-Theta 표기

# O(Big-Oh) 표기법
- 상수 배제
'''
n = int(input())

for i in range(50):
    print(i)
    
-> 이 반복문은 50번 반복. O(50) : 상수 배수는 하지 않는다.
정답은 O(1)
'''

'''
O(5N) / O(2N) -> O(2N)이 더 빠르다 강조!
'''
- O(N) vs O(N**2) : O(N)이 복잡도도 낮고 더 좋은 성능을 나타냄
N = 10000
로그 밑은 2
- O(N) : 10000
- O(N**2) : 100000000
- O(logn) : 2**N = 10000 이니깐 14회로 추정한다. 올림처리 2**14 하면 10000이 조금 넘어.
- 세 개 중 O(logn)이 가장 효율성이 좋음
- O(NlogN)은 O(N) 보다 느리지만 유사한 성능을 낸다고 볼 수 있다.

- pop(0) : O(n)
- popleft() : O(1) / deque모듈
- O(logn) -> 예시_이진탐색
- O(nlogn) -> 예시_sort

# 진수
- 10진수 : 사람이 사용하는 진수
- 2진수 : 컴퓨터가 사용하는 진수
- 16진수 : 2진수를 더 가독성 있게 사용. 연산 속도가 매우 빠름
(win+R calc -> 계산기 , alt+4 프로그래머)

## 진법 변환
10진수를 타진수로 변환
예제 : (149)10 = (10010101)2 10진수를 2진수로 바꿈

'''
구현
tar = 149
result = []

while tar != 0:
    result.append(tar % 2) # 나머지를 계속 추가
    tar // 2
result.reverse() # 뒤집기
print(result)
'''
표 암기 권장 하기!!
2진수에서 16진수로 변환하기
- 4자리수끼리 끊어주기
- 11/0010/1111 : 0x32f

'''
# 하드코딩, 미리 리스트로 할당
['0000', '0001', '0010', ..., '1111']
idx 0   1 ... 15
-> arr[7] + arr[3]
'''
0x가 붙으면 16진수